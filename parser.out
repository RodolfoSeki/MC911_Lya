Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Unused terminals:

    RETURN
    OR
    ARROW
    LT
    PROC
    END
    COLON
    FALSE
    WHILE
    CHARS
    GEQ
    AND
    RETURNS
    IN
    FI
    RESULT
    PLUS
    LOWER
    DO
    MINUS
    SCONST
    CCONST
    LOC
    OD
    NULL
    LBRACKET
    ABS
    UPPER
    RPAREN
    RBRACKET
    EXIT
    NUM
    NOT
    ELSE
    TRUE
    FOR
    ELSIF
    LEQ
    ARRAY
    EQ
    REF
    LENGTH
    ASC
    SYN
    GT
    LPAREN
    NE
    DOWN
    PRINT
    READ
    TYPE
    BY
    IF
    TO
    THEN

Grammar

Rule 0     S' -> program
Rule 1     program -> statement_list
Rule 2     statement_list -> statement
Rule 3     statement_list -> statement_list statement
Rule 4     statement -> declaration_statement
Rule 5     declaration_statement -> DCL declaration_list SEMI
Rule 6     declaration_list -> declaration
Rule 7     declaration_list -> declaration_list COMMA declaration
Rule 8     declaration -> identifier_list mode
Rule 9     declaration -> identifier_list mode initialization
Rule 10    initialization -> EQUALS expression
Rule 11    identifier_list -> identifier
Rule 12    identifier_list -> identifier_list COMMA identifier
Rule 13    identifier -> ID
Rule 14    mode -> discrete_mode
Rule 15    discrete_mode -> INT
Rule 16    discrete_mode -> BOOL
Rule 17    discrete_mode -> CHAR
Rule 18    expression -> operand0
Rule 19    operand0 -> operand1
Rule 20    operand1 -> operand2
Rule 21    operand2 -> operand3
Rule 22    operand2 -> operand2 arithmetic_multiplicative_operator operand3
Rule 23    operand3 -> ICONST
Rule 24    arithmetic_multiplicative_operator -> TIMES
Rule 25    arithmetic_multiplicative_operator -> DIVIDE
Rule 26    arithmetic_multiplicative_operator -> MODULO

Terminals, with rules where they appear

ABS                  : 
AND                  : 
ARRAY                : 
ARROW                : 
ASC                  : 
BOOL                 : 16
BY                   : 
CCONST               : 
CHAR                 : 17
CHARS                : 
COLON                : 
COMMA                : 7 12
DCL                  : 5
DIVIDE               : 25
DO                   : 
DOWN                 : 
ELSE                 : 
ELSIF                : 
END                  : 
EQ                   : 
EQUALS               : 10
EXIT                 : 
FALSE                : 
FI                   : 
FOR                  : 
GEQ                  : 
GT                   : 
ICONST               : 23
ID                   : 13
IF                   : 
IN                   : 
INT                  : 15
LBRACKET             : 
LENGTH               : 
LEQ                  : 
LOC                  : 
LOWER                : 
LPAREN               : 
LT                   : 
MINUS                : 
MODULO               : 26
NE                   : 
NOT                  : 
NULL                 : 
NUM                  : 
OD                   : 
OR                   : 
PLUS                 : 
PRINT                : 
PROC                 : 
RBRACKET             : 
READ                 : 
REF                  : 
RESULT               : 
RETURN               : 
RETURNS              : 
RPAREN               : 
SCONST               : 
SEMI                 : 5
SYN                  : 
THEN                 : 
TIMES                : 24
TO                   : 
TRUE                 : 
TYPE                 : 
UPPER                : 
WHILE                : 
error                : 

Nonterminals, with rules where they appear

arithmetic_multiplicative_operator : 22
declaration          : 6 7
declaration_list     : 5 7
declaration_statement : 4
discrete_mode        : 14
expression           : 10
identifier           : 11 12
identifier_list      : 8 9 12
initialization       : 9
mode                 : 8 9
operand0             : 18
operand1             : 19
operand2             : 20 22
operand3             : 21 22
program              : 0
statement            : 2 3
statement_list       : 1 3

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statement_list
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . declaration_statement
    (5) declaration_statement -> . DCL declaration_list SEMI

    DCL             shift and go to state 5

    statement_list                 shift and go to state 1
    declaration_statement          shift and go to state 4
    program                        shift and go to state 2
    statement                      shift and go to state 3

state 1

    (1) program -> statement_list .
    (3) statement_list -> statement_list . statement
    (4) statement -> . declaration_statement
    (5) declaration_statement -> . DCL declaration_list SEMI

    $end            reduce using rule 1 (program -> statement_list .)
    DCL             shift and go to state 5

    declaration_statement          shift and go to state 4
    statement                      shift and go to state 6

state 2

    (0) S' -> program .



state 3

    (2) statement_list -> statement .

    DCL             reduce using rule 2 (statement_list -> statement .)
    $end            reduce using rule 2 (statement_list -> statement .)


state 4

    (4) statement -> declaration_statement .

    DCL             reduce using rule 4 (statement -> declaration_statement .)
    $end            reduce using rule 4 (statement -> declaration_statement .)


state 5

    (5) declaration_statement -> DCL . declaration_list SEMI
    (6) declaration_list -> . declaration
    (7) declaration_list -> . declaration_list COMMA declaration
    (8) declaration -> . identifier_list mode
    (9) declaration -> . identifier_list mode initialization
    (11) identifier_list -> . identifier
    (12) identifier_list -> . identifier_list COMMA identifier
    (13) identifier -> . ID

    ID              shift and go to state 11

    declaration_list               shift and go to state 7
    declaration                    shift and go to state 8
    identifier                     shift and go to state 10
    identifier_list                shift and go to state 9

state 6

    (3) statement_list -> statement_list statement .

    DCL             reduce using rule 3 (statement_list -> statement_list statement .)
    $end            reduce using rule 3 (statement_list -> statement_list statement .)


state 7

    (5) declaration_statement -> DCL declaration_list . SEMI
    (7) declaration_list -> declaration_list . COMMA declaration

    SEMI            shift and go to state 12
    COMMA           shift and go to state 13


state 8

    (6) declaration_list -> declaration .

    SEMI            reduce using rule 6 (declaration_list -> declaration .)
    COMMA           reduce using rule 6 (declaration_list -> declaration .)


state 9

    (8) declaration -> identifier_list . mode
    (9) declaration -> identifier_list . mode initialization
    (12) identifier_list -> identifier_list . COMMA identifier
    (14) mode -> . discrete_mode
    (15) discrete_mode -> . INT
    (16) discrete_mode -> . BOOL
    (17) discrete_mode -> . CHAR

    COMMA           shift and go to state 17
    INT             shift and go to state 19
    BOOL            shift and go to state 15
    CHAR            shift and go to state 16

    mode                           shift and go to state 18
    discrete_mode                  shift and go to state 14

state 10

    (11) identifier_list -> identifier .

    COMMA           reduce using rule 11 (identifier_list -> identifier .)
    INT             reduce using rule 11 (identifier_list -> identifier .)
    BOOL            reduce using rule 11 (identifier_list -> identifier .)
    CHAR            reduce using rule 11 (identifier_list -> identifier .)


state 11

    (13) identifier -> ID .

    COMMA           reduce using rule 13 (identifier -> ID .)
    INT             reduce using rule 13 (identifier -> ID .)
    BOOL            reduce using rule 13 (identifier -> ID .)
    CHAR            reduce using rule 13 (identifier -> ID .)


state 12

    (5) declaration_statement -> DCL declaration_list SEMI .

    DCL             reduce using rule 5 (declaration_statement -> DCL declaration_list SEMI .)
    $end            reduce using rule 5 (declaration_statement -> DCL declaration_list SEMI .)


state 13

    (7) declaration_list -> declaration_list COMMA . declaration
    (8) declaration -> . identifier_list mode
    (9) declaration -> . identifier_list mode initialization
    (11) identifier_list -> . identifier
    (12) identifier_list -> . identifier_list COMMA identifier
    (13) identifier -> . ID

    ID              shift and go to state 11

    declaration                    shift and go to state 20
    identifier                     shift and go to state 10
    identifier_list                shift and go to state 9

state 14

    (14) mode -> discrete_mode .

    EQUALS          reduce using rule 14 (mode -> discrete_mode .)
    SEMI            reduce using rule 14 (mode -> discrete_mode .)
    COMMA           reduce using rule 14 (mode -> discrete_mode .)


state 15

    (16) discrete_mode -> BOOL .

    EQUALS          reduce using rule 16 (discrete_mode -> BOOL .)
    SEMI            reduce using rule 16 (discrete_mode -> BOOL .)
    COMMA           reduce using rule 16 (discrete_mode -> BOOL .)


state 16

    (17) discrete_mode -> CHAR .

    EQUALS          reduce using rule 17 (discrete_mode -> CHAR .)
    SEMI            reduce using rule 17 (discrete_mode -> CHAR .)
    COMMA           reduce using rule 17 (discrete_mode -> CHAR .)


state 17

    (12) identifier_list -> identifier_list COMMA . identifier
    (13) identifier -> . ID

    ID              shift and go to state 11

    identifier                     shift and go to state 21

state 18

    (8) declaration -> identifier_list mode .
    (9) declaration -> identifier_list mode . initialization
    (10) initialization -> . EQUALS expression

    SEMI            reduce using rule 8 (declaration -> identifier_list mode .)
    COMMA           reduce using rule 8 (declaration -> identifier_list mode .)
    EQUALS          shift and go to state 23

    initialization                 shift and go to state 22

state 19

    (15) discrete_mode -> INT .

    EQUALS          reduce using rule 15 (discrete_mode -> INT .)
    SEMI            reduce using rule 15 (discrete_mode -> INT .)
    COMMA           reduce using rule 15 (discrete_mode -> INT .)


state 20

    (7) declaration_list -> declaration_list COMMA declaration .

    SEMI            reduce using rule 7 (declaration_list -> declaration_list COMMA declaration .)
    COMMA           reduce using rule 7 (declaration_list -> declaration_list COMMA declaration .)


state 21

    (12) identifier_list -> identifier_list COMMA identifier .

    COMMA           reduce using rule 12 (identifier_list -> identifier_list COMMA identifier .)
    INT             reduce using rule 12 (identifier_list -> identifier_list COMMA identifier .)
    BOOL            reduce using rule 12 (identifier_list -> identifier_list COMMA identifier .)
    CHAR            reduce using rule 12 (identifier_list -> identifier_list COMMA identifier .)


state 22

    (9) declaration -> identifier_list mode initialization .

    SEMI            reduce using rule 9 (declaration -> identifier_list mode initialization .)
    COMMA           reduce using rule 9 (declaration -> identifier_list mode initialization .)


state 23

    (10) initialization -> EQUALS . expression
    (18) expression -> . operand0
    (19) operand0 -> . operand1
    (20) operand1 -> . operand2
    (21) operand2 -> . operand3
    (22) operand2 -> . operand2 arithmetic_multiplicative_operator operand3
    (23) operand3 -> . ICONST

    ICONST          shift and go to state 26

    operand0                       shift and go to state 25
    operand3                       shift and go to state 24
    expression                     shift and go to state 27
    operand2                       shift and go to state 28
    operand1                       shift and go to state 29

state 24

    (21) operand2 -> operand3 .

    TIMES           reduce using rule 21 (operand2 -> operand3 .)
    DIVIDE          reduce using rule 21 (operand2 -> operand3 .)
    MODULO          reduce using rule 21 (operand2 -> operand3 .)
    SEMI            reduce using rule 21 (operand2 -> operand3 .)
    COMMA           reduce using rule 21 (operand2 -> operand3 .)


state 25

    (18) expression -> operand0 .

    SEMI            reduce using rule 18 (expression -> operand0 .)
    COMMA           reduce using rule 18 (expression -> operand0 .)


state 26

    (23) operand3 -> ICONST .

    TIMES           reduce using rule 23 (operand3 -> ICONST .)
    DIVIDE          reduce using rule 23 (operand3 -> ICONST .)
    MODULO          reduce using rule 23 (operand3 -> ICONST .)
    SEMI            reduce using rule 23 (operand3 -> ICONST .)
    COMMA           reduce using rule 23 (operand3 -> ICONST .)


state 27

    (10) initialization -> EQUALS expression .

    SEMI            reduce using rule 10 (initialization -> EQUALS expression .)
    COMMA           reduce using rule 10 (initialization -> EQUALS expression .)


state 28

    (20) operand1 -> operand2 .
    (22) operand2 -> operand2 . arithmetic_multiplicative_operator operand3
    (24) arithmetic_multiplicative_operator -> . TIMES
    (25) arithmetic_multiplicative_operator -> . DIVIDE
    (26) arithmetic_multiplicative_operator -> . MODULO

    SEMI            reduce using rule 20 (operand1 -> operand2 .)
    COMMA           reduce using rule 20 (operand1 -> operand2 .)
    TIMES           shift and go to state 30
    DIVIDE          shift and go to state 33
    MODULO          shift and go to state 32

    arithmetic_multiplicative_operator shift and go to state 31

state 29

    (19) operand0 -> operand1 .

    SEMI            reduce using rule 19 (operand0 -> operand1 .)
    COMMA           reduce using rule 19 (operand0 -> operand1 .)


state 30

    (24) arithmetic_multiplicative_operator -> TIMES .

    ICONST          reduce using rule 24 (arithmetic_multiplicative_operator -> TIMES .)


state 31

    (22) operand2 -> operand2 arithmetic_multiplicative_operator . operand3
    (23) operand3 -> . ICONST

    ICONST          shift and go to state 26

    operand3                       shift and go to state 34

state 32

    (26) arithmetic_multiplicative_operator -> MODULO .

    ICONST          reduce using rule 26 (arithmetic_multiplicative_operator -> MODULO .)


state 33

    (25) arithmetic_multiplicative_operator -> DIVIDE .

    ICONST          reduce using rule 25 (arithmetic_multiplicative_operator -> DIVIDE .)


state 34

    (22) operand2 -> operand2 arithmetic_multiplicative_operator operand3 .

    TIMES           reduce using rule 22 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    DIVIDE          reduce using rule 22 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    MODULO          reduce using rule 22 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    SEMI            reduce using rule 22 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)
    COMMA           reduce using rule 22 (operand2 -> operand2 arithmetic_multiplicative_operator operand3 .)

