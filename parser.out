Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Unused terminals:

    DO
    LOWER
    RETURN
    THEN
    READ
    END
    LBRACKET
    WHILE
    PRINT
    FI
    NULL
    REF
    GEQ
    DCL
    SEMI
    TRUE
    NE
    SCONST
    BY
    ASC
    TO
    LT
    NUM
    COLON
    ARRAY
    CCONST
    GT
    MODULO
    FOR
    UPPER
    EQUALS
    LOC
    RETURNS
    ABS
    RESULT
    ARROW
    IN
    BOOL
    ELSE
    EQ
    IF
    AND
    DOWN
    FALSE
    CHAR
    INT
    PROC
    CHARS
    OD
    ELSIF
    SYN
    LEQ
    LENGTH
    EXIT
    NOT
    RBRACKET
    COMMA
    TYPE
    OR

Grammar

Rule 0     S' -> expression
Rule 1     expression -> expression PLUS term
Rule 2     expression -> expression MINUS term
Rule 3     expression -> term
Rule 4     term -> term TIMES factor
Rule 5     term -> term DIVIDE factor
Rule 6     term -> factor
Rule 7     factor -> ICONST
Rule 8     factor -> ID
Rule 9     factor -> LPAREN expression RPAREN

Terminals, with rules where they appear

ABS                  : 
AND                  : 
ARRAY                : 
ARROW                : 
ASC                  : 
BOOL                 : 
BY                   : 
CCONST               : 
CHAR                 : 
CHARS                : 
COLON                : 
COMMA                : 
DCL                  : 
DIVIDE               : 5
DO                   : 
DOWN                 : 
ELSE                 : 
ELSIF                : 
END                  : 
EQ                   : 
EQUALS               : 
EXIT                 : 
FALSE                : 
FI                   : 
FOR                  : 
GEQ                  : 
GT                   : 
ICONST               : 7
ID                   : 8
IF                   : 
IN                   : 
INT                  : 
LBRACKET             : 
LENGTH               : 
LEQ                  : 
LOC                  : 
LOWER                : 
LPAREN               : 9
LT                   : 
MINUS                : 2
MODULO               : 
NE                   : 
NOT                  : 
NULL                 : 
NUM                  : 
OD                   : 
OR                   : 
PLUS                 : 1
PRINT                : 
PROC                 : 
RBRACKET             : 
READ                 : 
REF                  : 
RESULT               : 
RETURN               : 
RETURNS              : 
RPAREN               : 9
SCONST               : 
SEMI                 : 
SYN                  : 
THEN                 : 
TIMES                : 4
TO                   : 
TRUE                 : 
TYPE                 : 
UPPER                : 
WHILE                : 
error                : 

Nonterminals, with rules where they appear

expression           : 1 2 9 0
factor               : 4 5 6
term                 : 1 2 3 4 5

Parsing method: LALR

state 0

    (0) S' -> . expression
    (1) expression -> . expression PLUS term
    (2) expression -> . expression MINUS term
    (3) expression -> . term
    (4) term -> . term TIMES factor
    (5) term -> . term DIVIDE factor
    (6) term -> . factor
    (7) factor -> . ICONST
    (8) factor -> . ID
    (9) factor -> . LPAREN expression RPAREN

    ICONST          shift and go to state 4
    ID              shift and go to state 5
    LPAREN          shift and go to state 2

    term                           shift and go to state 1
    expression                     shift and go to state 6
    factor                         shift and go to state 3

state 1

    (3) expression -> term .
    (4) term -> term . TIMES factor
    (5) term -> term . DIVIDE factor

    RPAREN          reduce using rule 3 (expression -> term .)
    PLUS            reduce using rule 3 (expression -> term .)
    MINUS           reduce using rule 3 (expression -> term .)
    $end            reduce using rule 3 (expression -> term .)
    TIMES           shift and go to state 8
    DIVIDE          shift and go to state 7


state 2

    (9) factor -> LPAREN . expression RPAREN
    (1) expression -> . expression PLUS term
    (2) expression -> . expression MINUS term
    (3) expression -> . term
    (4) term -> . term TIMES factor
    (5) term -> . term DIVIDE factor
    (6) term -> . factor
    (7) factor -> . ICONST
    (8) factor -> . ID
    (9) factor -> . LPAREN expression RPAREN

    ICONST          shift and go to state 4
    ID              shift and go to state 5
    LPAREN          shift and go to state 2

    term                           shift and go to state 1
    expression                     shift and go to state 9
    factor                         shift and go to state 3

state 3

    (6) term -> factor .

    TIMES           reduce using rule 6 (term -> factor .)
    DIVIDE          reduce using rule 6 (term -> factor .)
    PLUS            reduce using rule 6 (term -> factor .)
    MINUS           reduce using rule 6 (term -> factor .)
    $end            reduce using rule 6 (term -> factor .)
    RPAREN          reduce using rule 6 (term -> factor .)


state 4

    (7) factor -> ICONST .

    TIMES           reduce using rule 7 (factor -> ICONST .)
    DIVIDE          reduce using rule 7 (factor -> ICONST .)
    PLUS            reduce using rule 7 (factor -> ICONST .)
    MINUS           reduce using rule 7 (factor -> ICONST .)
    $end            reduce using rule 7 (factor -> ICONST .)
    RPAREN          reduce using rule 7 (factor -> ICONST .)


state 5

    (8) factor -> ID .

    TIMES           reduce using rule 8 (factor -> ID .)
    DIVIDE          reduce using rule 8 (factor -> ID .)
    PLUS            reduce using rule 8 (factor -> ID .)
    MINUS           reduce using rule 8 (factor -> ID .)
    $end            reduce using rule 8 (factor -> ID .)
    RPAREN          reduce using rule 8 (factor -> ID .)


state 6

    (0) S' -> expression .
    (1) expression -> expression . PLUS term
    (2) expression -> expression . MINUS term

    PLUS            shift and go to state 10
    MINUS           shift and go to state 11


state 7

    (5) term -> term DIVIDE . factor
    (7) factor -> . ICONST
    (8) factor -> . ID
    (9) factor -> . LPAREN expression RPAREN

    ICONST          shift and go to state 4
    ID              shift and go to state 5
    LPAREN          shift and go to state 2

    factor                         shift and go to state 12

state 8

    (4) term -> term TIMES . factor
    (7) factor -> . ICONST
    (8) factor -> . ID
    (9) factor -> . LPAREN expression RPAREN

    ICONST          shift and go to state 4
    ID              shift and go to state 5
    LPAREN          shift and go to state 2

    factor                         shift and go to state 13

state 9

    (9) factor -> LPAREN expression . RPAREN
    (1) expression -> expression . PLUS term
    (2) expression -> expression . MINUS term

    RPAREN          shift and go to state 14
    PLUS            shift and go to state 10
    MINUS           shift and go to state 11


state 10

    (1) expression -> expression PLUS . term
    (4) term -> . term TIMES factor
    (5) term -> . term DIVIDE factor
    (6) term -> . factor
    (7) factor -> . ICONST
    (8) factor -> . ID
    (9) factor -> . LPAREN expression RPAREN

    ICONST          shift and go to state 4
    ID              shift and go to state 5
    LPAREN          shift and go to state 2

    term                           shift and go to state 15
    factor                         shift and go to state 3

state 11

    (2) expression -> expression MINUS . term
    (4) term -> . term TIMES factor
    (5) term -> . term DIVIDE factor
    (6) term -> . factor
    (7) factor -> . ICONST
    (8) factor -> . ID
    (9) factor -> . LPAREN expression RPAREN

    ICONST          shift and go to state 4
    ID              shift and go to state 5
    LPAREN          shift and go to state 2

    term                           shift and go to state 16
    factor                         shift and go to state 3

state 12

    (5) term -> term DIVIDE factor .

    TIMES           reduce using rule 5 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 5 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 5 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 5 (term -> term DIVIDE factor .)
    $end            reduce using rule 5 (term -> term DIVIDE factor .)
    RPAREN          reduce using rule 5 (term -> term DIVIDE factor .)


state 13

    (4) term -> term TIMES factor .

    TIMES           reduce using rule 4 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 4 (term -> term TIMES factor .)
    PLUS            reduce using rule 4 (term -> term TIMES factor .)
    MINUS           reduce using rule 4 (term -> term TIMES factor .)
    $end            reduce using rule 4 (term -> term TIMES factor .)
    RPAREN          reduce using rule 4 (term -> term TIMES factor .)


state 14

    (9) factor -> LPAREN expression RPAREN .

    TIMES           reduce using rule 9 (factor -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 9 (factor -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 9 (factor -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 9 (factor -> LPAREN expression RPAREN .)
    $end            reduce using rule 9 (factor -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 9 (factor -> LPAREN expression RPAREN .)


state 15

    (1) expression -> expression PLUS term .
    (4) term -> term . TIMES factor
    (5) term -> term . DIVIDE factor

    RPAREN          reduce using rule 1 (expression -> expression PLUS term .)
    PLUS            reduce using rule 1 (expression -> expression PLUS term .)
    MINUS           reduce using rule 1 (expression -> expression PLUS term .)
    $end            reduce using rule 1 (expression -> expression PLUS term .)
    TIMES           shift and go to state 8
    DIVIDE          shift and go to state 7


state 16

    (2) expression -> expression MINUS term .
    (4) term -> term . TIMES factor
    (5) term -> term . DIVIDE factor

    RPAREN          reduce using rule 2 (expression -> expression MINUS term .)
    PLUS            reduce using rule 2 (expression -> expression MINUS term .)
    MINUS           reduce using rule 2 (expression -> expression MINUS term .)
    $end            reduce using rule 2 (expression -> expression MINUS term .)
    TIMES           shift and go to state 8
    DIVIDE          shift and go to state 7

