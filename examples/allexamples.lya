/* example1: */
dcl m,n,s int;

read(m,n);
s = 0;
do while m <= n;
  s += m * n;
  print(m,s);
  m += 1;
od;

/* example2: */

dcl z,t int;

g: proc (t int);
  dcl x int;
  t *= 2;
  x  = 2*t;
  z  = x+1;
end;

z = 3;
t = 4;
g(t); print(z,t);
g(z); print(z,t);
g(t+z); print(z,t);
g(7); print(z,t);

/* example3: */

dcl m int;

f: proc (n int, k int loc) returns (int);
  dcl p,q,t int;
  if n<2 then
    k = 0;
    result n;
  else
    t = f(n-1,p) + f(n-2,q);
    k = p + q + 1;
    result t;
  fi;
end;

print(f(3,m), m);

/* example4: */
 
dcl z,x int;

g: proc (t int);
   dcl y int;
   y = t * t;
   z = z + x + y;
   print(z);
end;

h: proc (y int);
  dcl x int;  
  f: proc (y int);
    dcl t int;
    t = z + x + y;
    g(t);
    z = t;
  end;  
  x = y + 1;
  f(x);
  g(z + x);
end;

z = 1;
x = 3;
h(x);
g(x);
print(x,z);

/* Compute the fatorial of an integer */

fat: proc (n int) returns (int);
  if n==0 then
    return 1;
  else
    return n * fat (n-1);
  fi;
end;

dcl x int;
print("give-me a positive integer:");
read(x);
print("fatorial of ", x, " = ", fat(x));

/* Compute the Fibonacci of an integer */

fibo: proc (n int, g int loc);
  dcl h int;
  if n < 0 then
    print(g);
    return;
  else
    h = g; fibo(n-1, h);
    g = h; fibo(n-2, g);
  fi;
  print(n,g);
end;

dcl k int = 0;
fibo(3,k);
fibo(-1,k);

/* Compute GCD of two integers */

gcd: proc (x int, y int) returns (int);
  dcl g int;
  g = y;
  do
    while x > 0;
      g = x;
      x = y - (y/x) * x;
      y = g;
  od;
  return g;
end;

dcl a, b int;
print("give-me two integers separated by space:");
read (a,b);
print ("GCD of ", a, b, " is ", gcd(a,b));

/* Palindrome numbers: */

dcl n,t int, reverse int = 0;

print("Enter a number: ");
read(n);
t = n;
do 
  while t != 0;
    reverse = reverse * 10;
    reverse = reverse + t % 10;
    t = t / 10;
od;
if n == reverse then
  print(n, " is a palindrome number.\n");
else
  print(n, " is not a palindrome number.\n");
fi;

/* Bubble sort code: */
 
dcl v array[0:100] int;
dcl n, c, d, swap  int;

print("Enter number of elements: ");
read(n);
print("Enter ", n, " integers\n");
do
  for c = 0 to n-1;
    read(v[c]);
od;
do
  for c = 0 to n-2;
    do
      for d = 0 to n-c-2;
        // For decreasing order use "<"    
        if v[d] > v[d+1] then
          swap   = v[d];
          v[d]   = v[d+1];
          v[d+1] = swap;
        fi;
    od;
od;
print("Sorted list in ascending order:\n");
do
  for c = 0 to n-1;
    print(v[c], " ");
od;

/* Check Armstrong Number: */

// Armstrong number is a number which is equal to sum of digits
// raise to the power total number of digits in the number. Ex:
// 0, 1, 2, 3, 153, 370, 407, 1634, 8208

power: proc (n int, r int) returns (int);
  dcl c int, p int = 1;
  do 
    for c = 1 to r;
      p = p*n;
  od;
  return p;   
end;

dcl n int, sum int = 0;
dcl temp, remainder int, digits int = 0;
 
print("Input an integer: ");
read(n);
temp = n;
do
  while temp != 0;
    digits += 1;
    temp = temp / 10;
od;
temp = n;
do 
  while temp != 0;
    remainder = temp % 10;
    sum = sum + power(remainder, digits);
    temp = temp / 10;
od;
if n == sum then
  print(n, " is an Armstrong number.\n");
else
  print(n, " is not an Armstrong number.\n");
fi;

/* Display all prime numbers between two given
  intervals (greater than 2): */

dcl n1, n2, i, j int, flag bool;

print("Enter 2 numbers (intervals) separated by space: ");
read(n1, n2);
print("Prime numbers between ", n1, " and ", n2, " are:\n");
do
  for i = n1 to n2;
    flag = true;
    loop: do
      for j = 2 to i/2;
        if i % j == 0 then
          flag = false;
          exit loop;
        fi;
    od;
    if flag then
      print(i, "  ");
    fi;
od;

/* Stack of integers */
syn top int = 10;
type stack = array [1:top+1] int;

push: proc (s stack loc, elem int);
    if s[top+1] == top then
        print("stack is full");
    else
        s[top+1] += 1;
	s[s[top+1]] = elem;
    fi;
end;

pop: proc (s stack loc) returns (int);
    if s[top+1] == 0 then
        print("empty stack");
	result 0;
    else
        result s[s[top+1]];
	s[top+1] -= 1;
    fi;
end;

init: proc (s stack loc);
    s[top+1] = 0;
end;

dcl q stack, v1, v2 int;
init(q);
read(v1, v2);
push(q,v1);
push(q,v2);
print(pop(q) + pop(q));

